/**
 * @fileoverview Script to analyze test coverage for D-Loop Protocol contracts
 * 
 * This script analyzes the coverage report generated by solidity-coverage
 * and identifies contracts and functions with insufficient test coverage.
 */

const fs = require('fs');
const path = require('path');

// Configuration
const COVERAGE_FILE = path.resolve(__dirname, '../coverage/coverage.json');
const COVERAGE_THRESHOLD = {
  core: 95,
  governance: 90,
  fees: 90,
  token: 90,
  identity: 90,
  other: 80
};

// Critical functions that must have 100% coverage
const CRITICAL_FUNCTIONS = [
  'ProtocolDAO.createProposal',
  'ProtocolDAO.executeProposal',
  'ProtocolDAO.castVote',
  'AssetDAO.invest',
  'AssetDAO.divest',
  'AINodeRegistry.registerNode',
  'AINodeRegistry.updateNodeState',
  'Treasury.processFees',
  'FeeProcessor.calculateFee',
  'SoulboundNFT.mint',
  'DLoopToken.delegateTokens'
];

/**
 * Analyzes the coverage report
 */
function analyzeCoverage() {
  console.log('Analyzing test coverage for D-Loop Protocol contracts...');
  
  try {
    const coverageData = JSON.parse(fs.readFileSync(COVERAGE_FILE, 'utf8'));
    
    // Group contracts by type
    const contractsByType = {
      core: [],
      governance: [],
      fees: [],
      token: [],
      identity: [],
      other: []
    };
    
    // Analyze each contract
    for (const [filePath, data] of Object.entries(coverageData)) {
      const contractName = path.basename(filePath).replace('.sol', '');
      const contractType = getContractType(filePath);
      
      const statements = data.statementMap ? Object.keys(data.statementMap).length : 0;
      const coveredStatements = data.s ? Object.values(data.s).filter(v => v > 0).length : 0;
      const coverage = statements > 0 ? (coveredStatements / statements) * 100 : 0;
      
      const contractData = {
        name: contractName,
        path: filePath,
        statements,
        coveredStatements,
        coverage: Math.round(coverage * 100) / 100,
        functions: []
      };
      
      // Analyze functions
      if (data.fnMap) {
        for (const [fnId, fnData] of Object.entries(data.fnMap)) {
          const fnName = fnData.name;
          const fnCovered = data.f && data.f[fnId] > 0;
          
          contractData.functions.push({
            name: fnName,
            covered: fnCovered,
            isCritical: CRITICAL_FUNCTIONS.includes(`${contractName}.${fnName}`)
          });
        }
      }
      
      contractsByType[contractType].push(contractData);
    }
    
    // Generate report
    console.log('\n=== D-Loop Protocol Test Coverage Report ===\n');
    
    for (const [type, contracts] of Object.entries(contractsByType)) {
      if (contracts.length === 0) continue;
      
      console.log(`\n## ${type.toUpperCase()} CONTRACTS\n`);
      console.log('| Contract | Coverage | Status |');
      console.log('|----------|----------|--------|');
      
      const threshold = COVERAGE_THRESHOLD[type];
      
      for (const contract of contracts) {
        const status = contract.coverage >= threshold ? '✅' : '❌';
        console.log(`| ${contract.name} | ${contract.coverage}% | ${status} |`);
      }
      
      // Check critical functions
      const criticalFunctions = contracts
        .flatMap(c => c.functions.filter(f => f.isCritical).map(f => ({ contract: c.name, function: f.name, covered: f.covered })));
      
      if (criticalFunctions.length > 0) {
        console.log('\nCritical Functions:');
        console.log('| Contract | Function | Covered |');
        console.log('|----------|----------|---------|');
        
        for (const fn of criticalFunctions) {
          const status = fn.covered ? '✅' : '❌';
          console.log(`| ${fn.contract} | ${fn.function} | ${status} |`);
        }
      }
    }
    
    // Summary
    console.log('\n=== SUMMARY ===\n');
    
    for (const [type, contracts] of Object.entries(contractsByType)) {
      if (contracts.length === 0) continue;
      
      const avgCoverage = contracts.reduce((sum, c) => sum + c.coverage, 0) / contracts.length;
      const threshold = COVERAGE_THRESHOLD[type];
      const status = avgCoverage >= threshold ? '✅' : '❌';
      
      console.log(`${type.toUpperCase()}: ${Math.round(avgCoverage * 100) / 100}% (Threshold: ${threshold}%) ${status}`);
    }
    
    console.log('\nCoverage analysis complete!');
    
  } catch (error) {
    console.error('Error analyzing coverage:', error);
    console.error('Make sure to run "npx hardhat coverage" first to generate the coverage report.');
  }
}

/**
 * Determines the contract type based on the file path
 * @param {string} filePath - Path to the contract file
 * @returns {string} Contract type
 */
function getContractType(filePath) {
  if (filePath.includes('/core/')) return 'core';
  if (filePath.includes('/governance/')) return 'governance';
  if (filePath.includes('/fees/')) return 'fees';
  if (filePath.includes('/token/')) return 'token';
  if (filePath.includes('/identity/')) return 'identity';
  return 'other';
}

// Run the analysis
analyzeCoverage();
