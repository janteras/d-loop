/**
 * Minimal AINodeRegistry SoulboundNFT Integration Test
 * No external dependencies, only hardhat runtime
 */

const { expect } = require("chai");
const hre = require("hardhat");

// Custom parseUnits function without ethers
function parseUnits(value, decimals = 18) {
  return BigInt(Math.floor(Number(value) * 10**Number(decimals)));
}

describe("Minimal AINodeRegistry SoulboundNFT Integration", function() {
  let accounts, admin, user;
  let soulboundNFT, registry, mockToken;
  const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
  
  // Use Hardhat Runtime Environment directly
  before(async function() {
    try {
      // Get accounts directly from network
      accounts = await hre.network.provider.request({
        method: "eth_accounts"
      });
      
      console.log("Accounts:", accounts);
      admin = accounts[0];
      user = accounts[1];
      
      // Get contract factory and deploy
      const SoulboundNFT = await hre.ethers.getContractFactory("SoulboundNFT", {
        signer: await hre.ethers.provider.getSigner(admin)
      });
      soulboundNFT = await SoulboundNFT.deploy(admin);
      const soulboundNFTAddress = await soulboundNFT.getAddress();
      
      console.log("SoulboundNFT deployed at:", soulboundNFTAddress);
      
      // Deploy mock token
      const MockToken = await hre.ethers.getContractFactory("MockERC20", {
        signer: await hre.ethers.provider.getSigner(admin)
      });
      mockToken = await MockToken.deploy("DLOOP", "DLOOP", 18);
      const mockTokenAddress = await mockToken.getAddress();
      
      console.log("MockToken deployed at:", mockTokenAddress);
      
      // Mint tokens to user
      await mockToken.mint(user, parseUnits("1000", 18));
      
      // Deploy registry
      const AINodeRegistry = await hre.ethers.getContractFactory("AINodeRegistry", {
        signer: await hre.ethers.provider.getSigner(admin)
      });
      registry = await AINodeRegistry.deploy(admin, ZERO_ADDRESS, soulboundNFTAddress);
      const registryAddress = await registry.getAddress();
      
      console.log("AINodeRegistry deployed at:", registryAddress);
      
      // Setup token requirements
      await registry.setTokenRequirement(1, mockTokenAddress, parseUnits("100", 18), true);
      
      // Approve tokens
      const userSigner = await hre.ethers.provider.getSigner(user);
      const mockTokenWithUser = mockToken.connect(userSigner);
      await mockTokenWithUser.approve(registryAddress, parseUnits("1000", 18));
      
      console.log("Test setup complete");
    } catch (error) {
      console.error("Setup error:", error);
      throw error;
    }
  });
  
  it("should mint a SoulboundNFT when registering a node", async function() {
    try {
      const nodeAddress = "0x1111111111111111111111111111111111111111";
      const metadata = "ipfs://node-metadata-1";
      
      // Register node
      await registry.registerNode(nodeAddress, user, metadata);
      
      // Check node details
      const nodeDetails = await registry.getNodeDetails(nodeAddress);
      console.log("Node details:", nodeDetails);
      
      expect(nodeDetails.nodeOwner).to.equal(user);
      expect(nodeDetails.metadata).to.equal(metadata);
      expect(nodeDetails.soulboundTokenId).to.be.greaterThan(0);
      
      // Check NFT details
      const tokenId = nodeDetails.soulboundTokenId;
      const tokenDetails = await soulboundNFT.getTokenDetails(tokenId);
      
      expect(tokenDetails.tokenOwner).to.equal(user);
      expect(tokenDetails.tokenURI).to.equal(metadata);
      expect(tokenDetails.revoked).to.be.false;
      
      console.log("Test passed");
    } catch (error) {
      console.error("Test error:", error);
      throw error;
    }
  });
});